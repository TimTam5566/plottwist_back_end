"""

============================================================
DJANGO SETTINGS - The Control Center of Your Backend
============================================================
This file configures EVERYTHING about how Django runs.
The "settings menu" for your entire backend.

Django settings for plottwist project.

Generated by 'django-admin startproject' using Django 5.1.


"""

from pathlib import Path
import os
import dj_database_url
from dotenv import load_dotenv


# ============================================================
# ENVIRONMENT VARIABLES
# ============================================================

load_dotenv("../.env")

"""
Loads secret values from a .env file (which is NOT in git!)

Your .env file might look like:
    DJANGO_SECRET_KEY=some-super-secret-key
    CLOUDINARY_CLOUD_NAME=
    DATABASE_URL=

WHY?
- Keeps secrets out of your code
- Different values for development vs production
- Security best practice!
"""

# Build paths inside the project like this: BASE_DIR / 'subdir'.
BASE_DIR = Path(__file__).resolve().parent.parent
# BASE_DIR = the root folder of your Django project
# Used for file paths throughout settings


# ============================================================
# SECURITY SETTINGS
# ============================================================
SECRET_KEY = os.environ.get(
    'DJANGO_SECRET_KEY',
    'django-insecure-2$zvw(=aq-s-$wvznkcr%u4mi#zlx=81ej4sevr&cihkgv(8rg'
)
"""
SECRET_KEY:
- Used for cryptographic signing (sessions, tokens, etc.)
- MUST be kept secret in production!
- The fallback value is only for development
- On Heroku, set DJANGO_SECRET_KEY in config vars
"""

DEBUG = True
"""
DEBUG MODE:
- True = show detailed error pages (great for development)
- False = show generic errors (required for production!)

NOTE: This should be False in production!
You had commented-out code to set it from environment variable - 
that's the right approach for production.
"""

ALLOWED_HOSTS = ['*'] # any host is allowed 
"""
ALLOWED_HOSTS:
Which domain names can access this Django site.
'*' means any domain - fine for development, but in production
you'd want: ['plot-twist-you-are-the-author.herokuapp.com']
"""
# ============================================================
# CORS SETTINGS - Cross-Origin Resource Sharing
# ============================================================
CORS_ALLOW_ALL_ORIGINS = True # any origin is allowed

CORS_ALLOWED_ORIGINS = [
    "http://localhost:5173",  # Your Vite dev server
    "http://localhost:3000",  # Your Vite dev server
    "https://your-production-frontend.com"  # Your production frontend
]
"""
CORS EXPLAINED:
By default, browsers block requests from one domain to another.
Your React app (localhost:5173) and Django (localhost:8000) are different "origins".

CORS headers tell the browser: "It's okay, let this frontend talk to me!"

CORS_ORIGIN_ALLOW_ALL = True overrides the list below.
In production, you'd set this to False and list only your real frontend URL.
"""

CORS_ALLOW_CREDENTIALS = True # Allow cookies/auth tokens to be sent with requests

CORS_ALLOW_METHODS = [
    "DELETE",
    "GET",
    "OPTIONS",
    "PATCH",
    "POST",
    "PUT",
] # Which HTTP methods are allowed

CORS_ALLOW_HEADERS = [
    "accept",
    "authorization", # Important! Allows your auth token to be sent
    "content-type",
    "user-agent",
]

# ============================================================
# INSTALLED APPS - What's "plugged in" to Django
# ============================================================
INSTALLED_APPS = [
    # YOUR APPS (custom code)
    'projects.apps.ProjectsConfig', # Your projects app
    'users.apps.UsersConfig', # Your users app
    
    # THIRD-PARTY APPS (installed via pip)
    'rest_framework',  # Django REST Framework - for building APIs
    'rest_framework.authtoken', # Token authentication
    'corsheaders', # CORS handling
    'cloudinary_storage', # Cloudinary integration (BEFORE staticfiles!)
    'cloudinary', # Cloudinary base package

    # DJANGO BUILT-IN APPS
    'django.contrib.admin', # Admin panel at /admin/
    'django.contrib.auth', # User authentication system
    'django.contrib.contenttypes', # Content type framework
    'django.contrib.sessions', # Session management
    'django.contrib.messages', # Flash messages
    'django.contrib.staticfiles', # Static file handling
]
"""
ORDER MATTERS!
- cloudinary_storage must come BEFORE django.contrib.staticfiles
- Your apps usually go first
- Third-party apps in the middle
- Django built-ins last
"""

# ============================================================
# AUTHENTICATION
# ============================================================
AUTH_USER_MODEL = 'users.CustomUser'
"""
Tells Django: "Use MY CustomUser model instead of the built-in User"
This is why we created CustomUser in users/models.py
"""

REST_FRAMEWORK = {
    'DEFAULT_AUTHENTICATION_CLASSES': [
        'rest_framework.authentication.TokenAuthentication',
    ]
}
"""
TOKEN AUTHENTICATION:
Instead of sessions/cookies, we use tokens.

How it works:
1. User logs in with username/password
2. Server returns a token: "abc123xyz"
3. Frontend stores the token
4. Every request includes: Authorization: Token abc123xyz
5. Django checks the token to identify the user

This is standard for APIs that serve mobile apps or SPAs (React).
"""
# ============================================================
# MIDDLEWARE - Request/Response Processing Pipeline
# ============================================================
MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'corsheaders.middleware.CorsMiddleware', # CORS - must be high up!
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
    'whitenoise.middleware.WhiteNoiseMiddleware', # Serves static files
]
"""
MIDDLEWARE EXPLAINED:
Every request passes through these "layers" in order.
Every response passes back through in reverse order.

Think of it like airport security - each checkpoint does one thing:
- SecurityMiddleware: HTTPS, security headers
- SessionMiddleware: Session handling
- CorsMiddleware: Add CORS headers
- CommonMiddleware: URL normalization
- CsrfViewMiddleware: CSRF protection
- AuthenticationMiddleware: Attach user to request
- WhiteNoiseMiddleware: Serve static files efficiently
"""

# ============================================================
# URL & TEMPLATE CONFIGURATION
# ============================================================
ROOT_URLCONF = 'plottwist.urls'
# "Start URL routing from plottwist/urls.py"

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]
# Template settings - not really used since we are using React for frontend

WSGI_APPLICATION = 'plottwist.wsgi.application'
# Entry point for web servers (Heroku uses this)


# ============================================================
# DATABASE
# ============================================================
DATABASES = {
    'default': dj_database_url.config(
        default=f'sqlite:///{BASE_DIR}/db.sqlite3',
        conn_max_age=600
    )
}
"""
DATABASE CONFIGURATION:

dj_database_url.config() is clever:
- In DEVELOPMENT: Uses SQLite (simple file-based database)
- In PRODUCTION: Reads DATABASE_URL environment variable (Heroku sets this!)

Heroku automatically provides a PostgreSQL database and sets DATABASE_URL.
So locally you use SQLite, on Heroku you use PostgreSQL - same code!

conn_max_age=600: Keep database connections open for 10 minutes (performance)
"""


# ============================================================
# PASSWORD VALIDATION
# ============================================================

AUTH_PASSWORD_VALIDATORS = [
    {
        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
        # Can't use your username as password
    },
    {
        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
        # Must be at least 8 characters
    },
    {
        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
        # Can't use common passwords like "password123"
    },
    {
        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
        # Can't be all numbers
    },
]


# ============================================================
# INTERNATIONALIZATION
# ============================================================

LANGUAGE_CODE = 'en-us'

TIME_ZONE = 'UTC'

USE_I18N = True # Internationalization (translations)

USE_TZ = True # Timezone-aware datetimes


# ============================================================
# STATIC & MEDIA FILES
# ============================================================
STATIC_URL = '/static/'
STATIC_ROOT = BASE_DIR / 'staticfiles'
"""
STATIC FILES: CSS, JavaScript, images that are part of your app
- STATIC_URL: URL prefix for static files
- STATIC_ROOT: Where collectstatic gathers files for production
"""

MEDIA_URL = '/media/'
MEDIA_ROOT = BASE_DIR / 'media'
"""
MEDIA FILES: User-uploaded content (like project images)
- These settings are somewhat overridden by Cloudinary now
- But kept for local development fallback
"""

DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'
# Default primary key type for models

# ============================================================
# CLOUDINARY CONFIGURATION ☁️
# ============================================================
CLOUDINARY_STORAGE = {
    'CLOUD_NAME': os.environ.get('CLOUDINARY_CLOUD_NAME'),
    'API_KEY': os.environ.get('CLOUDINARY_API_KEY'),
    'API_SECRET': os.environ.get('CLOUDINARY_API_SECRET'),
}
''' 
Your Cloudinary account credentials.
These come from environment variables (set on Heroku).

CLOUD_NAME: Your unique Cloudinary identifier
API_KEY: Public key for API access
API_SECRET: Private key (keep secret!)

'''

STORAGES = {
    "default": {
        "BACKEND": "cloudinary_storage.storage.MediaCloudinaryStorage",
    },
    "staticfiles": {
        "BACKEND": "whitenoise.storage.CompressedManifestStaticFilesStorage",
    },
}
"""
STORAGES (Django 5+ way):

"default" = Where to store MEDIA files (user uploads)
→ Uses Cloudinary! All ImageFields automatically upload to Cloudinary.

"staticfiles" = Where to store STATIC files (CSS, JS, admin assets)
→ Uses WhiteNoise for efficient serving

THIS IS THE KEY SETTING that makes Cloudinary work automatically!
"""